# Processor
## NAME (NETID)
Luke Andresen (LJA26)
## Description of Design
This module builds upon the previous ECE 350 checkpoints (being the ALU, RegFile, and Multdiv modules) to create a 5 stage pipelined processor that uses bypassing for further optimization. The only new elements included in this module are the pipeline latches, which are simply multiple registers and D flip-flops containted within one module for organizational purposes. These latches are set on the falling edge of the clock, and contain things like instructions, program counters, register outputs, ALU outputs in more. In each stage, there is also a decoder that decodes the instruction opcode of each stage for ease of control. The first stage of this processor is the Fetch stage, which contains the program counter register, the PC incrementer, and the imem to supply the instructions based on the current PC. The FD latch contains just PC+1 and the current instruction. The second stage is the decode stage, which contains the regster file. There is a bit of control that checks for specific special register read cases (like store word or immediate instructions). The DX latch contains the corrosponding PC and instruction, as well as both outputs of the register file. The execute stage contains the ALU, the branch adder, and the multdiv module. It also builds the immediete and decides baded on the opcode if it should be inputted into the ALU. If there is an ALu exception in this stage, the processor replaces the instruction with a SETX that corrosponds to the exception that is being thrown. When activated, the multdiv module halts the pipeline to allow for these two computationally intensive processes to run. The instruction, multdiv hazard, and output of the multdiv module are stored in the PW latch. The XM latch again contains the corrospinding PC and instruction, but also takes the output alu and the stored value of RegB (unless it is bypassed, more below). The memory stage contains the dmem and memory handeling. The MW latch again contains the PC and instruction, as well as the stored value of the ALU output from the XM latch and the output of the dmem. The writeback stage decided if it should write back an the output of memory, the output of the ALU, or the output of multdiv based on the opcode and multdiv being ready. The writeback also checks for multdiv exceptions and writes accordingly. This processor handles instructions as defined in the ECE 350 Processor Assignment Document.
## Bypassing
The bypassing is fundamentally run by 4 control wires: ctrl_alu_a (3 bits), ctrl_alu_b (4 bits), ctrl_jr (3 bits), and ctrl_memd (1 bit). Each of these controls a specific bypass tournary operator (passing values back in the pipeline for optimization). They control the alu/multdiv input A and B, the jump register bypassing, and the memory bypassing respectivly. 
## Stalling
This processor stalls on only when executing multdiv or during the special bypassing edge case of passing the output of a load to the ALU input as covered in class. To stall, the processor simply identifies if multdiv is running or if we are in the special case and disables the PC register and FD latch, stopping new instructions from entering the pipeline untill the multdiv is done or the hazard is cleared.
## Optimizations
The largest optimization was the bypassing detailed above, but I applied some other small optimizations as I went, like jumping in the decode stage or using modified booths algorithm,.
## Bugs
There are no known bugs in this module.